/*

 flock protocol
 
 v4 emphasis on messaging. added packet() and message()
    methods, API changes.

 v4 unified machine (base vs. bird), switched on
    identity. the machine is now called packet(),
    to accomodate the message() layer.

 v3 new packet model; bad-channel stats and
    dynamic channel mapping.

 v2 uses separate rx, tx buffers, declared in userland.

 v1 discovers fixed base channel via
    SCISSORS protocol subset.

  tom jennings
  
 TODO:


  07 aug 2015  	beginning Peep dev. added powerUp() method
  		that powers the radio up and restarts
		the Flock state machine.
  07 aug 2015  message() returns sender ID (char) not packet length.
  04 aug 2015  shortened LED on times.
  25 jul 2015  dispatchers are now passed (int, unsigned) to 
               accommodate checksum errors (checksums not used
	       in radio.)
  16 jul 2015  now using SRPRNG exclusively.
  13 jul 2015  added getIdentity()
  04 jul 2015  added passthrough for powerDown()
  03 jul 2015  c/Parser/Dispatcher/ to match change in SRMessage.
  29 jun 2015  Flock read and write now assumes null-terminated strings.
  25 jun 2015  unified the two models (base, bird) into one (machine).
               now contains packet() and message() methods. many
	       changes to API.
               commented out stray debug print in bad channel.
               valid packet receipt addressed to us acked, even
	       if not from base (previously, only from base).
  06 jun 2015  const int def's generate compiler complain?
               changed to #defines
  17 may 2015  badChan[] table too small! moved xor() stuff
               into SRResources.
  10 may 2015  added setPromiscuous(). nasty bug -- ackPacket()
               writes in pxBuff, called before copyN.
  05 may 2015  implemented CRC-base duplicate detection, and 
               simple double-write in write() to increase delivery
	       probability. the latter needs to be true retry for
	       writing packets requesting ack but the dup detection
	       should be run for a while first.
	       added minChannel, maxChannel settable limits; the
               SMA connectored radios don't seem to do low
	       channels well. increased LED on times.
  03 may 2015  updates for changed LED api. split RX timeout
               methods in two: RxAR (ack request) and RxAT (ack
	       timeout) to be able to do multiple requests
	       within timeout.
  26 apr 2015  rxpower works now. improved rx timeout
               methods. added connect() method and logic.
	       CRC dup idea is fail.
  25 apr 2015  eep! radio.setChannel() wasn't called at
               channel changes! stuck on 80! shortened
	       inter-channel seek delay. changed flockToBaseState()
	       to return channel number. channel 126
	       does not work! lower MAX
  23 apr 2015  added setChannel() and setRxTO(). added
               channel quality and new channel selection
	       logic for BaseToFLock().
  21 apr 2015  resets RXTIMER, RXTOTIMER if we see any
               packet from @ in getPacket(), as a way
	       to avoid requesting keepalive.
  18 apr 2015  v3 protocol seems to be working, is a hell
               of a lot simpler and smaller. added radio 
	       pass-through methods.
  17 apr 2015  v3; vastly simplified protocol.
  15 apr 2015  v2; separate rx, tx buffers, in userland,
               passed in begin(); separate, internal
	       protocol packet buffer. this vastly simplifies
	       data handling. this does require copying
	       payload in to/out of buffers, which
	       could be eliminated with split read() write()
	       as contemplated.
  14 apr 2015  removed nested ifs in flockToBase(),
               replaced with getPacket(). aargh, missing 
	       parens around mask AND.
  10 apr 2015  added LED stuff, fixed flockToBaseState()
  18 mar 2015  new

*/


#ifndef __SRFLOCK_H__
#define __SRFLOCK_H__

#if ARDUINO < 100
#include <WProgram.h>
#else
#include <Arduino.h>
#endif

#include <stddef.h>

#ifdef ARDUINO
#else
#include <stdint.h>
#include <stdio.h>
#include <string.h>
typedef uint16_t prog_uint16_t;
#endif

const uint8_t MINCHANNEL = 1;			// Nordic chip hardware limits
const uint8_t MAXCHANNEL = 125;
const uint8_t PACKETSIZE = 32;

// our customary radio pins.
//
const int NRFCEpin = 9;
const int NRFCSNpin = 10;


class SRFlock {

	// timer stuff.
//
#define __FLOCKRADIOTIMER 0
#define __FLOCK_RXTIMER 1
#define __FLOCK_RXTOTIMER  2
#define __FLOCK_NUMTIMERS  3
#define __FLOCK_LEDBLIP  5
#define __FLOCK_LEDBRIEF 10
#define __FLOCK_LEDLONG (600)
#define __FLOCK_MAXRXTO  60

public:
	int begin ();
	int begin (uint8_t cepin, uint8_t cspin);
	void setIdentity (char id);
	unsigned char getIdentity ();
	void LED (uint8_t pin);
	int packet();
	char message();
	bool connected();
	int status();
	int packetWrite (uint8_t n);
	int packetWrite (char *p, uint8_t n);
	int write ();
	char * getRxBuff();
	char * getTxBuff();

// connection control
//
	void setRxAR (uint8_t sec);
	void setRxAT (uint8_t sec);
	void setChanThresh (uint8_t t);
	void setPromiscuous(bool yup);
	void dynamicChannelEnable();
	void dynamicChannelDisable();
	void nextChannel();
	uint8_t getChanError();
	uint8_t * getChanErrorMap ();
	uint8_t getChanThresh();
	void powerDown ();
	void powerUp ();
	bool powerState();

// radio pass-through functions
//
	void setFixedAddress (uint64_t t, uint64_t r);
	void setSelfAddress (uint64_t base, uint8_t t, uint8_t r);
	void setSelfAddress (uint8_t t, uint8_t r);

	void setChannel (uint8_t channel);
	void setMinChannel (uint8_t channel);
	void setMaxChannel (uint8_t channel);
	void setDataRate (uint8_t n);
	void setPALevel (uint8_t n);

	uint8_t getChannel();
	uint8_t getRxPower();
	uint8_t readRegister (uint8_t r);

// Message parser methods, a mix of custom/local and
// passthrough.
//
	void addDispatcher (bool (* func) (int, unsigned));
	int messageBegin ();
	int messageTo (char dest, bool ack);
	int messageAdd (char c, unsigned nnn);
	int messageEnd();

protected:
	void blink (uint8_t n);
	void ackPacket (char id, bool req);
	int getPacket (bool broadcast, bool promisc);
	void copyN (char * d, char * s, uint8_t n);
	uint8_t newChan (uint8_t badChan);
	uint8_t dupCheck (uint8_t r);
	uint8_t crc8 (uint8_t crc, uint8_t data);
	uint8_t crc8buff (char * p, uint8_t n);

private:
	SRRF24 radio;				// radio chip driver
	SRTimer T;				// software timers
	SRCRC8 CRC;				// CRC for data packets
	SRPRNG PRNG;				// minimal PRNG
	SRLED RFLED;				// our RF activity status LED
	SRMessage MSG;				// messaging system
	uint8_t LEDpin;				// optional

	uint8_t cepin;
	uint8_t csnpin;
	char identity;				// our identity (A..Z)
	uint8_t state;				// protocol state machine
	uint8_t channel;			// current radio channel
	uint8_t minChannel;			// the SMA radios lousy at
	uint8_t maxChannel;			// low channels...
	uint8_t cstate;				// connect-state report state

	char * txBuff;				// tx buffer, in userland 
	char * rxBuff;				// rx buffer, in userland 
	char pxBuff[PACKETSIZE];		// protocol packet buffer
	bool connectState;			// true if connected
	bool promisc;				// true if receive any packet
	bool poweroff;				// true if chip powered off
	unsigned rxTimeout;			// rx timeout time, decisec
	uint8_t rxPower;			// receive power indication
	bool dynamicChannelMapping;		// enables channel mapping
	uint8_t ackBalance;			// channel error logic
	uint8_t chanThresh;			//
	uint8_t badChan[16];			// bad channels, 0..127, bitmap
	uint8_t prevCRC;			// CRC8 of previous payload 
	char seqNumber;				// packet sequence character

};


/*
  begin/setup Flock protocol.
*/

// use the default pins for the radio and allocate buffers internally.
//
int SRFlock::begin() {

	return begin (NRFCEpin, NRFCSNpin);
}

// allocate buffers internally.
//
int SRFlock::begin (uint8_t cepin, uint8_t csnpin) {

	// the extra byte is so that we can null-terminate delivered
	// packets without messing about.
	//
	rxBuff= new char [PACKETSIZE + 1];
	txBuff= new char [PACKETSIZE + 1];

	T.begin (__FLOCK_NUMTIMERS);			// init timers
	MSG.begin();					// ready message parser
	CRC.begin();					// probably does nothing
	PRNG.begin();					// local PRNGs
	LEDpin= 0;					// see LED() for begin()

	state= 0;					// our state machine
	connectState= false;				// no Flock connect
	promisc= false;					// no promiscuous RX
	poweroff= false;				// chip is ready
	dynamicChannelMapping= true;			// on by default

	int r= radio.begin (cepin, csnpin); 		// set up radio hardware
	radio.setAutoAck (false);			// make sure this is off
	setPALevel (3);					// highest power 
	PRNG.xor16Seed (micros());			// seed the 16 PRNG
	channel= newChan (0);				// for baseToFlock()
	radio.setChannel (channel);
	chanThresh= 10;					// outstanding ack limit
	minChannel= 20;					// set default range
	maxChannel= 120;
	prevCRC= 0;
	seqNumber= '0';					// first packet sequence
	setRxAR (6);					// ack request interval
	setRxAT (31);					// ack req fail interval
	cstate= 255;
	return r;
}

/*
  set our identity and the state machine to use.

*/
void SRFlock::setIdentity (char id) { 

	identity= id; 
	state= identity == '@' ? 4 : 0;			// where to start
}


// power management methods. after powerDown() is invoked, only
// powerUp(), powerState(), connectState() are allowed.
//
void SRFlock::powerUp () { 

	connectState= false;				// not connected yet
	cstate= 0;					// stadystate= down
	radio.available(); 				// ready the chip
	setIdentity (identity);				// resets state machine
	poweroff= false;
}

void SRFlock::powerDown () { 	
	
	connectState= false;
	cstate= 0;
	setIdentity (identity);
	radio.powerDown(); 
	poweroff= true;
}

bool SRFlock::powerState () {

	return ! poweroff;
}

/* 
  Flock message protocol. message() accepts message+address+ack request
  via packet(), strips the header and delivers any messages via the
  dispatcher(s).

  the returned byte count is for the raw payload, in rxBuff. it is
  possible for there to be no messages with a non-zero return, eg.
  ack/ack request packets.

  as a side effect the dispatcher gets the optional protocol
  byte, ! or -, as the first character in the message string.

 */

char SRFlock::message () {
int r;

	r= packet();
	if (r == 0) return '\0';			// no packet

	rxBuff [r]= '\0';				// null terminate it
	MSG.rxString (rxBuff + 2);			// dispatch messages
	return rxBuff[1];				// return sender
}

/* this is the Flock packet machine, which handles both flock-to-base and
base-to-flock. the state variable is initialized by setIdentity -- if @ then
this runs baseToFlock and the state never changes.  the Flock-to-base state
machine changes state accordingly.

  0 no data received. this means either no packet at all, a protocol packet
  (eaten by the state machine)

  1..32 a packet with valid payload received and is now in buff[]. note that
  the first two bytes of the packet are protocol overhead.

  -1 read error, which really means code, driver, or hardware error.
*/

int SRFlock::packet () {

	if (LEDpin) RFLED.LED();			// run LEDs 

	uint8_t r= 0;
	switch (state) {

// FLOCK TO BASE -------------------------------------------------------------
//
		// search for the operating channel by pinging random
		// channels looking for a response from Base.
		//
		case 0:	
			nextChannel();			// select a new channel
			connectState= false;		// not connected
			state= 1;

		// blindly transmit an ack request, setup to wait
		// for a response.
		//
		case 1:
			ackPacket ('@', true);		// request ack
			T.setTimer (__FLOCKRADIOTIMER, 5);
			state= 2;			// await response
			break;

		// request sent; watch for response (connected on
		// current channel) or timeout (try next channel).
		//
		case 2:	
			if (getPacket (false, false)) {	// if a packet for us,
				unsigned x= __FLOCK_LEDLONG;
				blink (x);
				state= 3;		// we're in sync
				connectState= true;	// we are connected

			} else if (T.timer (__FLOCKRADIOTIMER)) {
				state= 0;
			}
			break;

		// presumably "connected" which simply means we've communicated
		// with the base within the alloted time. poll for incoming
		// packets, respond to ack requests and channel-change hints,
		// deal with timeout, deliver payload to userland.
		//
		case 3:	
			r= getPacket (true, promisc);	// what we got?
			r= dupCheck (r);		// check if duplicate

			// if a valid packet, deliver any payload. watch
			// for ack request and channel-change hint.
			//
			if (r) {
				copyN (rxBuff, pxBuff, r);// deliver payload
				if (pxBuff[0] == identity) {
					if (pxBuff[2] == '!') 
						ackPacket (pxBuff[1], false);
					if (pxBuff[2] == '-') {
						Serial.println ("XXX hint");
						state= 0;
					}
				}
			}

			// if we go long enough without seeing a packet,
			// request ack from the base. this timer is shorter
			// than RXTOTIMER.
			//
			if (rxTimeout && T.timer (__FLOCK_RXTIMER)) 
				ackPacket ('@', true);

			// if we never hear a response, restart protocol.
			// this timer is longer than RXTIMER.
			//
			if (rxTimeout && T.timer (__FLOCK_RXTOTIMER)) {
				state= 0;
				Serial.println ("XXX RXTO");
			}
			break;

// BASE TO FLOCK -------------------------------------------------------------
//

		// Base protocol all resides in one state. incoming
		// packets get delivered and ack requests honored.
		// "connect state" is loosely defined as pack success
		// within the specified timeouts, and the number of
		// outstanding ack requests below threshhold.
		// 
		case 4:
			r= radio.available();		// ready/sample RX power
			if (r) {			// 0 else RX power
				rxPower= r;
				r= radio.read (pxBuff, PACKETSIZE);
			}

			// no-packet-received is when we check for timeouts
			// and ack request/reply imbalance. if we reach a
			// timeout, send a broadcast ack request. 
			// if we accumulate too many outstanding requests, 
			// issue a channel-change hint and change
			// channels, forcing birds to re-search for the Base.
			//
			if (r < 2) {
				// if we haven't seen a packet for a while,
				// broadcast an ack request.
				//
				if (rxTimeout && T.timer (__FLOCK_RXTIMER)) 
					ackPacket ('*', true);

				// check ack balance.
				//
				if (ackBalance > chanThresh) { 
					pxBuff[0]= '*';	
					pxBuff[1]= '@';
					pxBuff[2]= '-';	// channel change hint 
					radio.write (pxBuff, 3);
					radio.write (pxBuff, 3);

					nextChannel();
					connectState= false;
					T.trigTimer (__FLOCK_RXTIMER);
				}
				r= 0;			// setup return
				break;
			}

			// brief blip upon receipt of any valid packet.
			//
			blink (__FLOCK_LEDBLIP);

			// if the packet is for us, however, longer blink.
			// if not for us, we're done here.
			//
			if (pxBuff[0] != identity) {
				r= 0;
				break;
			}
			blink (__FLOCK_LEDBRIEF);

			// ack balance counts only packets addressed to us
			// directly since that's how they are sent.
			//
			if (ackBalance) --ackBalance;	

			// good packet, possibly contains payload. deliver
			// payload if present and not a dup.
			//
			connectState= true;	
			r= dupCheck (r);
			copyN (rxBuff, pxBuff, r);

			// honor ack requests.
			//
			if (r > 2 && pxBuff[2] == '!') {
				ackPacket (pxBuff[1], false);
			}
			break;
	}
	return r;
}

// send an empty packet as acknowledgement (req == false) or 
// include a single ! as payload (req == true). we up the ackBalance
// counter whenever we request an acknowledge; this is decremented
// upon receipt of any packet from Base.
//
void SRFlock::ackPacket (char dest, bool req) {

	pxBuff[0]= dest;				// set destination
	pxBuff[1]= identity;				// source: us
	uint8_t n= 2;					// packet length
	if (req) {
		pxBuff[n++]= '!';			// optional ack request
		++ackBalance;				// response required
	}
	radio.write (pxBuff, n);			// send packet
	blink (__FLOCK_LEDBLIP);			// blink LED
}

// look for a packet for us. reads any packet available, and checks
// for address and general validity. 
//
// the caller will check if acknowledgement needs to be sent, but 
// to simplify that test, if the packet is short we zero the first
// payload character so the caller doesn't need to check packet length.
//
// returns 0 is not a valid packet or not for us, else it returns
// the packet length. hence, it returns 0, or 2..32.
//
int SRFlock::getPacket (bool broadcast, bool promisc) {

	int r= radio.available();			// ready/sample RX power
	if (r) {					// 0 else RX power
		rxPower= r;
		r= radio.read (pxBuff, PACKETSIZE);	// read available packet
	}
	if (r < 2) return 0;				// invalid length
	blink (__FLOCK_LEDBLIP);			// blip for valid packet
	if (r < 3) pxBuff[2]= 0;			// see comment

	// if we see *any* packet from the base, we assume that
	// we are on the correct channel and that the channel is
	// alive. but is this always true? if we can RX base, can base RX us?
	// are there conditions where this isn't a good assumption? i
	// can't think of any.
	//
	if (pxBuff[1] == '@') {				// if from the base,
		PRNG.xor16();				// break the sequence
		T.resetTimer (__FLOCK_RXTIMER);		// channel is alive
		T.resetTimer (__FLOCK_RXTOTIMER);
	}

	// if it's to us, or accept broadcast is enabled, return the
	// packet.
	//
	if ((pxBuff[0] == identity) || (broadcast && (pxBuff[0] == '*'))) {
		if (ackBalance) --ackBalance;		// downcount ack balance
		blink (__FLOCK_LEDBRIEF);
		return r;
	}

	// a valid packet, but not to us. we toss it unless 
	// promiscuous.
	//
	return promisc ? r : 0;
}

// see if the packet in pxBuff of length r is a duplicate. this CRCs
// packets of three or more bytes and compares it against the previous
// CRC; if it's the same we call it a dup and trim it down to just the
// addresses and possible ack request. 
//
// (the sender makes packets CRC uniquely by appending a sequence number;
// this ensures that intentionally identical command strings in contiguous
// packets won't be dropped.)
//
// this returns the corrected packet length.
//
uint8_t SRFlock::dupCheck (uint8_t r) {

	if (r < 3) return r;				// not long enough to check
	int crc= CRC.crc8buff ((uint8_t *)pxBuff, r);	// CRC the packet
	if (crc == prevCRC) {				// if same as last time
		r= ((pxBuff[2] == '!') ? 3 : 2);	// include ! if present
	}
	prevCRC= crc;
	return r;
}

// returns Flock connection status change. connected() returns current
// state; this tracks changes.
//
// 0:    was, is, disconnected
// 1:    was discon, now connected
// 2:    was connected, now disconnected
// 3:    was, is, connected
//
//
int SRFlock::status () {

	cstate <<= 1;					// previous state 
	if (connectState) cstate |= 1;			// new state 
	cstate &= 3;					// this and last, only
	return cstate;
}

// transmit the contents of txBuff. if there is room, append the 
// sequence number. in the SR command syntax, this appears as a
// message payload without a command letter, and the command parser will 
// ignore it; but it will make the CRC for this packet unique to 
// this packet (and different from the CRC of otherwise identical 
// commands, with a different sequence).
//
int SRFlock::write () {

	int n= strlen (txBuff);				// payload length
	if (n >= PACKETSIZE) {				// oops, shit!
		strcpy (txBuff, "@@ UNTERMINATED!");
		n= sizeof ("@@ UNTERMINATED!");
	}
	return packetWrite (txBuff, n);
}

// write N bytes from the transmit buffer.
//
int SRFlock::packetWrite (uint8_t n) {

	return packetWrite (txBuff, n);
}

// write bytes from the buffer to the radio.
//
int SRFlock::packetWrite (char *s, uint8_t n) {

	PRNG.xor16();					// interrupt sequence
	if (! connectState) return -1;			// can't send now

	blink (__FLOCK_LEDBRIEF);
	copyN (pxBuff, txBuff, n);			// copy data in,

	if (n < PACKETSIZE - 1) {			// if there is room
		pxBuff[n++]= seqNumber;			// append sequence num
		if (++seqNumber > '9') seqNumber= '0';
		radio.write (pxBuff, n);		// additional write
		delayMicroseconds (PRNG.random16 (311, 1000));	// brief delay
	}

	if (n > 2 && pxBuff[2] == '!') {
		++ackBalance;				// require acknowledge
	}
	return radio.write (pxBuff, n);			// 
}

// selects a new radio channel and returns it, within the channel limits
// and dynamic channel selection. the specified channel, b, is marked as
// bad. this also randomly (5% of the time) marks a random channel as
// good, to both avoid running out of channels and to re-try channels
// once marked bad (environment changes).
//
// channel state is a bit map; 0/1 good/bad.
//
uint8_t SRFlock::newChan (uint8_t b) {

	if (! dynamicChannelMapping) return channel;

//	if (b != 0) {
//		Serial.print ("MAP BAD ");
//		Serial.println (b);
//	}

	// mark this channel as bad.
	//
	badChan [b / 8] |= 1 << (b % 8);		// mark bad,

	// select a new, random, channel that is not currently
	// marked as bad. also randomly (5% of the time) un-marks
	// a channel; this prevents entirely running out of channels,
	// and prevents inifnite looping, here. also, "bad" status
	// varies with time since interference varies.
	//
	uint8_t chan, r;
	do { 
		chan= PRNG.random16 (minChannel, maxChannel + 1);
		if (PRNG.random16 (1, 100) < 5) {	// 5% of the time,
			r= PRNG.random16 (minChannel, maxChannel + 1);
			badChan [r / 8] &= ~ (1 << (r % 8)); 
		}

	} while ((badChan [chan % 8] & (1 << (chan % 8)))); // loop while bad

	ackBalance= 0;
	return chan;
}

void SRFlock::setRxAR (uint8_t sec) { 
	if (sec < __FLOCK_MAXRXTO) 
		T.setDeciTimer (__FLOCK_RXTIMER, rxTimeout= sec * 10); 
};

void SRFlock::setRxAT (uint8_t sec) { 
	if (sec < __FLOCK_MAXRXTO) 
		T.setDeciTimer (__FLOCK_RXTOTIMER, sec * 10); 
};


// setup to use an LED for operational status.
//
void SRFlock::LED (uint8_t n) { RFLED.begin (LEDpin= n); }

// if configured, blink the LED for N mS.
//
void SRFlock::blink (uint8_t n) { if (LEDpin) RFLED.blink (n); }


// "simple" support functions.
//

unsigned char    SRFlock::getIdentity() {return identity;};
char * SRFlock::getRxBuff() {return rxBuff;};
char * SRFlock::getTxBuff() {return txBuff;};
void    SRFlock::dynamicChannelEnable() { dynamicChannelMapping= true; };
void    SRFlock::dynamicChannelDisable(){ dynamicChannelMapping= false; };
void    SRFlock::nextChannel() 		{ radio.setChannel (channel= newChan (0)); }
uint8_t SRFlock::getChannel() 		{ return channel; };
bool SRFlock::connected() 		{ return connectState; };
uint8_t SRFlock::getRxPower() 		{ return rxPower; };
uint8_t SRFlock::getChanError() 	{ return ackBalance; };
uint8_t * SRFlock::getChanErrorMap () 	{ return badChan; };
uint8_t SRFlock::getChanThresh()	{ return chanThresh; };
void    SRFlock::setChanThresh(uint8_t t){ chanThresh= t; };
void    SRFlock::setMinChannel (uint8_t ch) { if (ch >= MINCHANNEL) minChannel= ch; } 
void    SRFlock::setMaxChannel (uint8_t ch) { if (ch <= MAXCHANNEL) maxChannel= ch; }
void    SRFlock::setPromiscuous (bool f) { promisc= f; }

// pass-throughs to the radio object.
//
uint8_t SRFlock::readRegister (uint8_t r){ return radio.read_register (r); }
void SRFlock::setDataRate (uint8_t n) 	{ radio.setDataRate (n); }
void SRFlock::setPALevel (uint8_t n) 	{ radio.setPALevel (n); }
void SRFlock::setChannel (uint8_t ch) 	{ radio.setChannel (channel= ch); }
void SRFlock::setFixedAddress (uint64_t t, uint64_t r) 
					{ radio.setFixedAddress (t, r); }
void SRFlock::setSelfAddress (uint64_t base, uint8_t t, uint8_t r) 
					{ radio.setSelfAddress (base, t, r); }
void SRFlock::setSelfAddress (uint8_t t, uint8_t r) 
					{ radio.setSelfAddress (t, r); }


// local function: copy N bytes, from s to d.
//
void SRFlock::copyN (char * d, char * s, uint8_t n) {

	if (n > PACKETSIZE) n= PACKETSIZE;		// don't be a jerk.
	while (n--) *d++= *s++;
}

// add a parser, from userland, to the Flock radio system.
//
void SRFlock::addDispatcher (bool (* func) (int, unsigned)) {

	MSG.addDispatcher (func);
}

// the messsage creation methods are a subset of the SRMessage
// methods, and use local default values: txBuff, identity, etc.
// end() is unique to Flock.
//
int SRFlock::messageBegin () {

	MSG.messageBegin (txBuff, PACKETSIZE);
	return PACKETSIZE;
}

int SRFlock::messageTo (char dest, boolean ack) {

	MSG.messageChar (dest);		// to
	MSG.messageChar (identity);	// from
	if (ack) MSG.messageChar ('!');	// optional ack request
}

int SRFlock::messageAdd (char c, unsigned nnn) {

	MSG.messageAdd (c, nnn);
	return PACKETSIZE - strlen (txBuff);
}

// end the message, transmitting it. if the message has no payload, add
// ack request. things may not go well if the message is not well-formed.
//
int SRFlock::messageEnd () {

	if (txBuff[2] == '\0') {
		txBuff[2]= '!';
		txBuff[3]= '\0';
	}
	return write ();
}

// end of #ifndef __SRFLOCK_H__
#endif

